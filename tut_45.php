<?
$g_title = 'CZ NeHe OpenGL - Lekce 45 - Vertex Buffer Object (VBO)';
$g_description = 'NeHe OpenGL Tutoriály v èe¹tinì, programování 3D grafiky, èlánky, programy se zdrojovými kódy...';
$g_keywords = 'opengl, nehe, tutoriály, woq, programování, 3D';

include 'p_begin.php';
?>

<?FceImgNeHeMaly(45);?>

<h1>Lekce 45 - Vertex Buffer Object (VBO)</h1>

<p class="nadpis_clanku">Jeden z nejvìt¹ích problémù jakékoli 3D aplikace je zaji¹tìní její rychlosti. V¾dy byste mìli limitovat mno¾ství aktuálnì renderovaných polygonù buï øazením, cullingem nebo nìjakým algoritmem na sni¾ování detailù. Kdy¾ nic z toho nepomáhá, mù¾ete zkusit napøíklad vertex arrays. Moderní grafické karty nabízejí roz¹íøení nazvané vertex buffer object, které pracuje podobnì jako vertex arrays kromì toho, ¾e nahrává data do vysoce výkonné pamìti grafické karty, a tak podstatnì sni¾uje èas potøebný pro rendering. Samozøejmì ne v¹echny karty tato nová roz¹íøení podporují, tak¾e musíme implementovat i verzi zalo¾enou na vertex arrays.</p>

<div>V tomto tutoriálu budeme</div>
<ul>
<li>nahrávat data vý¹kové mapy</li>
<li>pou¾ívat vertex arrays k efektivnímu posílání dat vertexù do OpenGL</li>
<li>prostøednictvím VBO nahrávat data do pamìti grafické karty</li>
</ul>

<p>Jako v¾dy nejdøíve nadefinujeme parametry aplikace. První dvì symbolické konstanty pøedstavují rozli¹ení vý¹kové mapy a mìøítko pro vertikální roztáhnutí (viz. tutoriál 34 o vý¹kových mapách). Kdy¾ nadefinujete tøetí konstantu, v programu se vypne pou¾ívání VBO... abyste snadno mohli porovnat rychlostní rozdíl.</p>

<p class="src0"><span class="kom">// Parametry vý¹kové mapy</span></p>
<p class="src0">#define MESH_RESOLUTION 4.0f<span class="kom">// Poèet pixelù na vertex</span></p>
<p class="src0">#define MESH_HEIGHTSCALE 1.0f<span class="kom">// Mìøítko vyvý¹ení</span></p>
<p class="src0"><span class="kom">//#define NO_VBOS// Vypíná VBO</span></p>

<p>K definicím také musíme pøidat konstanty, datové typy a ukazatele na funkce pro VBO roz¹íøení. Zahrnul jsem jen parametry nutné pro toto demo. Pokud potøebujete více funkcionality, doporuèuji z <?OdkazBlank('http://www.opengl.org/');?> stáhnout nejnovìj¹í glext.h a pou¾ít definice obsa¾ené v nìm. Pro kód to jistì bude èistìj¹í metoda.</p>

<p class="src0"><span class="kom">// Roz¹íøení VBO z glext.h</span></p>
<p class="src0">#define GL_ARRAY_BUFFER_ARB 0x8892</p>
<p class="src0">#define GL_STATIC_DRAW_ARB 0x88E4</p>
<p class="src0">typedef void (APIENTRY * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);</p>
<p class="src0">typedef void (APIENTRY * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);</p>
<p class="src0">typedef void (APIENTRY * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);</p>
<p class="src0">typedef void (APIENTRY * PFNGLBUFFERDATAARBPROC) (GLenum target, int size, const GLvoid *data, GLenum usage);</p>
<p class="src"></p>
<p class="src0"><span class="kom">// Ukazatele na funkce pro VBO</span></p>
<p class="src0">PFNGLGENBUFFERSARBPROC glGenBuffersARB = NULL;<span class="kom">// Generování VBO jména</span></p>
<p class="src0">PFNGLBINDBUFFERARBPROC glBindBufferARB = NULL;<span class="kom">// Zvolení VBO bufferu</span></p>
<p class="src0">PFNGLBUFFERDATAARBPROC glBufferDataARB = NULL;<span class="kom">// Nahrávání dat VBO</span></p>
<p class="src0">PFNGLDELETEBUFFERSARBPROC glDeleteBuffersARB = NULL;<span class="kom">// Mazání VBO</span></p>

<p>Deklarujeme jednoduché tøídy vertexu a texturových koordinátù. CMesh je kompletní tøídou, která mù¾e zapouzdøit základní data meshe. V na¹em pøípadì se jedná o vý¹kovou mapu. Kód vysvìtluje sám sebe, v¹imnìte si akorát, ¾e data vertexù jsou oddìlená od texturových koordinátù do vlastního pole. Jak bude vysvìtleno dále, není to úplnì nutné.</p>

<p class="src0">class CVert<span class="kom">// Tøída vertexu</span></p>
<p class="src0">{</p>
<p class="src0">public:</p>
<p class="src1">float x;</p>
<p class="src1">float y;</p>
<p class="src1">float z;</p>
<p class="src0">};</p>
<p class="src0">typedef CVert CVec;<span class="kom">// Definice jsou synonymní</span></p>
<p class="src"></p>
<p class="src0">class CTexCoord<span class="kom">// Tøída texturových koordinátù</span></p>
<p class="src0">{</p>
<p class="src0">public:</p>
<p class="src1">float u;</p>
<p class="src1">float v;</p>
<p class="src0">};</p>
<p class="src"></p>
<p class="src0">class CMesh<span class="kom">// Tøída meshe (vý¹kové mapy)</span></p>
<p class="src0">{</p>
<p class="src0">public:</p>
<p class="src1">int m_nVertexCount;<span class="kom">// Poèet vertexù</span></p>
<p class="src1">CVert* m_pVertices;<span class="kom">// Souøadnice vertexù</span></p>
<p class="src1">CTexCoord* m_pTexCoords;<span class="kom">// Texturové koordináty</span></p>
<p class="src1">unsigned int m_nTextureId;<span class="kom">// ID textury</span></p>
<p class="src"></p>
<p class="src1">unsigned int m_nVBOVertices;<span class="kom">// Jméno (ID) VBO pro vertexy</span></p>
<p class="src1">unsigned int m_nVBOTexCoords;<span class="kom">// Jméno (ID) VBO pro texturové koordináty</span></p>
<p class="src"></p>
<p class="src1">AUX_RGBImageRec* m_pTextureImage;<span class="kom">// Data vý¹kové mapy</span></p>
<p class="src"></p>
<p class="src0">public:</p>
<p class="src1">CMesh();<span class="kom">// Konstruktor</span></p>
<p class="src1">~CMesh();<span class="kom">// Destruktor</span></p>
<p class="src"></p>
<p class="src1">bool LoadHeightmap(char* szPath, float flHeightScale, float flResolution);<span class="kom">// Loading vý¹kové mapy</span></p>
<p class="src1">float PtHeight(int nX, int nY);<span class="kom">// Hodnota na indexu vý¹kové mapy</span></p>
<p class="src1">void BuildVBOs();<span class="kom">// Vytvoøení VBO</span></p>
<p class="src0">};</p>

<p>Globální promìnná g_bVBOSupported indikuje podporu VBO ze strany grafické karty. Nastavíme ji v inicializaèním kódu. G_pMesh bude ukládat data vý¹kové mapy a g_flYRot urèuje úhel natoèení scény. Promìnná g_nFPS bude obsahovat poèet snímkù za sekundu a g_nFrames je èítaè jednotlivých snímkù. Poslední promìnná ukládá èas minulého výpoètu FPS.</p>

<p class="src0">bool g_fVBOSupported = false;<span class="kom">// Flag podpory VBO</span></p>
<p class="src0">CMesh* g_pMesh = NULL;<span class="kom">// Data meshe</span></p>
<p class="src0">float g_flYRot = 0.0f;<span class="kom">// Rotace</span></p>
<p class="src0">int g_nFPS = 0, g_nFrames = 0;<span class="kom">// FPS a èítaè pro FPS</span></p>
<p class="src0">DWORD g_dwLastFPS = 0;<span class="kom">// Èas minulého testu FPS</span></p>

<p>Funkce Loadheightmap() nahrává data vý¹kové mapy. Pro ty z vás, kteøí o nièem takovém je¹tì nesly¹eli (Pøekl.: v originále - kdo ¾ijete pod skálou :-). Vý¹ková mapa je dvou dimenzionální sada dat, vìt¹inou obrázek, který hodnotami jednotlivých pixelù specifikuje vertikální vý¹ku dané èásti terénu. Existuje mnoho rùzných zpùsobù, jak ji vytvoøit. Moje implementace naèítá tøí kanálovou RGB bitmapu a ke zji¹tìní vý¹ky pou¾ívá výpoèet luminance. Výsledná hodnota bude díky tomu stejná pro barevný i èernobílý obrázek. Osobnì doporuèuji ètyøkanálový formát vstupních dat, jako je napøíklad targa (.TGA) obrázek, u kterého alfa kanál mù¾e specifikovat vý¹ku. Nicménì pro úèely tohoto tutoriálu bude dostaèovat obyèejná bitmapa.</p>

<p>Ujistíme se, ¾e soubor obrázku existuje a pokud ano, loadujeme ho pomocí knihovny glaux. Vím, existují mnohem lep¹í cesty nahrávání obrázkù...</p>

<p class="src0">bool CMesh::LoadHeightmap(char* szPath, float flHeightScale, float flResolution)</p>
<p class="src0">{</p>
<p class="src1">FILE* fTest = fopen(szPath, &quot;r&quot;);<span class="kom">// Otevøení pro ètení</span></p>
<p class="src"></p>
<p class="src1">if (!fTest)</p>
<p class="src1">{</p>
<p class="src2">return false;</p>
<p class="src1">}</p>
<p class="src"></p>
<p class="src1">fclose(fTest);<span class="kom">// Uvolní handle</span></p>
<p class="src"></p>
<p class="src1">m_pTextureImage = auxDIBImageLoad(szPath);<span class="kom">// Nahraje obrázek</span></p>

<p>Vìci zaèínají být trochu zajímavìj¹í. Ze v¹eho nejdøíve bych chtìl poukázat, ¾e pro ka¾dý trojúhelník generuji tøi vertexy - jednotlivé body nejsou sdílené. Mìli byste to vìdìt u¾ pøed naèítáním.</p>

<p>Abychom mohli alokovat pamì» pro data, potøebujeme znát její velikost. Výpoèet je celkem jednoduchý ((¹íøka terénu / rozli¹ení) * (délka terénu / rozli¹ení) * 3 vertexy na trojúhelník * 2 trojúhelníky na ètverec). alokujeme pamì» pro vertexy i texturové koordináty, deklarujeme pomocné promìnné a ve tøech vnoøených cyklech nastavíme obì pole.</p>

<p class="src1"><span class="kom">// Generování pole vertexù</span></p>
<p class="src1">m_nVertexCount = (int)(m_pTextureImage-&gt;sizeX * m_pTextureImage-&gt;sizeY * 6 / (flResolution * flResolution));</p>
<p class="src"></p>
<p class="src1">m_pVertices = new CVec[m_nVertexCount];<span class="kom">// Alokace pamìti</span></p>
<p class="src1">m_pTexCoords = new CTexCoord[m_nVertexCount];</p>
<p class="src"></p>
<p class="src1">int nX, nZ, nTri, nIndex = 0;<span class="kom">// Pomocné</span></p>
<p class="src1">float flX, flZ;</p>
<p class="src"></p>
<p class="src1">for (nZ = 0; nZ &lt; m_pTextureImage-&gt;sizeY; nZ += (int)flResolution)</p>
<p class="src1">{</p>
<p class="src2">for (nX = 0; nX &lt; m_pTextureImage-&gt;sizeX; nX += (int)flResolution)</p>
<p class="src2">{</p>
<p class="src3">for (nTri = 0; nTri &lt; 6; nTri++)</p>
<p class="src3">{</p>
<p class="src4"><span class="kom">// Výpoèet x a z pozice bodu</span></p>
<p class="src4">flX = (float)nX + ((nTri == 1 || nTri == 2 || nTri == 5) ? flResolution : 0.0f);</p>
<p class="src4">flZ = (float)nZ + ((nTri == 2 || nTri == 4 || nTri == 5) ? flResolution : 0.0f);</p>
<p class="src"></p>
<p class="src4"><span class="kom">// Nastavení vertexu v poli</span></p>
<p class="src4">m_pVertices[nIndex].x = flX - (m_pTextureImage-&gt;sizeX / 2);</p>
<p class="src4">m_pVertices[nIndex].y = PtHeight((int)flX, (int)flZ) * flHeightScale;</p>
<p class="src4">m_pVertices[nIndex].z = flZ - (m_pTextureImage-&gt;sizeY / 2);</p>
<p class="src"></p>
<p class="src4"><span class="kom">// Nastavení texturových koordinátù v poli</span></p>
<p class="src4">m_pTexCoords[nIndex].u = flX / m_pTextureImage-&gt;sizeX;</p>
<p class="src4">m_pTexCoords[nIndex].v = flZ / m_pTextureImage-&gt;sizeY;</p>
<p class="src"></p>
<p class="src4">nIndex++;<span class="kom">// Inkrementace indexu</span></p>
<p class="src3">}</p>
<p class="src2">}</p>
<p class="src1">}</p>

<p>Z obrázku vý¹kové mapy vytvoøíme OpenGL texturu a potom uvolníme jeho pamì».</p>

<p class="src1">glGenTextures(1, &amp;m_nTextureId);<span class="kom">// OpenGL ID</span></p>
<p class="src1">glBindTexture(GL_TEXTURE_2D, m_nTextureId);<span class="kom">// Zvolí texturu</span></p>
<p class="src1">glTexImage2D(GL_TEXTURE_2D, 0, 3, m_pTextureImage-&gt;sizeX, m_pTextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, m_pTextureImage-&gt;data);<span class="kom">// Nahraje texturu do OpenGL</span></p>
<p class="src1">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);<span class="kom">// Lineární filtrování</span></p>
<p class="src1">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</p>
<p class="src"></p>
<p class="src1">if (m_pTextureImage)<span class="kom">// Uvolnìní pamìti</span></p>
<p class="src1">{</p>
<p class="src2">if (m_pTextureImage-&gt;data)</p>
<p class="src2">{</p>
<p class="src3">free(m_pTextureImage-&gt;data);</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">free(m_pTextureImage);</p>
<p class="src1">}</p>
<p class="src"></p>
<p class="src1">return true;</p>
<p class="src0">}</p>

<p>Funkce PtHeight() vypoèítá index do pole s daty, pøitom o¹etøí pøístup do nealokované pamìti a vrátí vý¹ku na daném indexu. Aby mohl být obrázek barevný i èernobílý, pou¾ijeme vzorec pro luminanci. Opravdu nic slo¾itého.</p>

<p class="src0">float CMesh::PtHeight(int nX, int nY)<span class="kom">// Vý¹ka na indexu</span></p>
<p class="src0">{</p>
<p class="src1"><span class="kom">// Výpoèet pozice v poli, o¹etøení pøeteèení</span></p>
<p class="src1">int nPos = ((nX % m_pTextureImage-&gt;sizeX) + ((nY % m_pTextureImage-&gt;sizeY) * m_pTextureImage-&gt;sizeX)) * 3;</p>
<p class="src"></p>
<p class="src1">float flR = (float)m_pTextureImage-&gt;data[nPos];<span class="kom">// Grabování slo¾ek barvy</span></p>
<p class="src1">float flG = (float)m_pTextureImage-&gt;data[nPos + 1];</p>
<p class="src1">float flB = (float)m_pTextureImage-&gt;data[nPos + 2];</p>
<p class="src"></p>
<p class="src1">return (0.299f * flR + 0.587f * flG + 0.114f * flB);<span class="kom">// Výpoèet luminance</span></p>
<p class="src0">}</p>

<p>V následující funkci zaèneme koneènì pracovat s vertex arrays a VBO. Tak¾e, co to jsou pole vertexù? V základu je to systém, díky kterému mù¾eme ukázat OpenGL na pole geometrických dat a potom je nìkolika málo pøíkazy vykreslit. Výsledkem je, ¾e odpadají spousty výskytù funkcí typu glVertex3f() a jiných, které svým mnohonásobným voláním zbyteènì zpomalují rendering. Systém vertex buffer object (VBO) jde je¹tì dále, namísto standardní pamìti aplikace alokované v RAM pou¾ívá vysoce výkonnou pamì» grafické karty. Èas renderingu se zkracuje také proto, ¾e data nemusí putovat &quot;po celém poèítaèi&quot;, ale jsou ulo¾ena pøímo na zaøízení, kde se pou¾ívají.</p>

<p>Tak¾e teï se chystáme vytvoøit Vertex Buffer Object. Pro tuto operaci existuje nìkolik mo¾ných zpùsobù realizace, jeden z nich se nazývá &quot;mapování&quot; pamìti. Myslím, ¾e na tomto místì bude nejlep¹í jít tou nejsnadnìj¹í cestou. Nejprve pomocí glGenBuffersARB() získáme validní jméno VBO. Je to vlastnì èíslo ID, které OpenGL asociuje s na¹imi daty. Dále, podobnì jako u textur, musíme VBO nastavit jako aktivní, èili øíct OpenGL, ¾e s ním chceme pracovat. K tomu slou¾í funkce glBindBufferARB(). Nakonec nahrajeme data do grafické karty. Funkci se pøedává velikost dat v bytech a ukazatel na nì. Proto¾e u¾ po této operaci nebudou potøeba, mù¾eme je smazat z RAM.</p>

<p class="src0">void CMesh::BuildVBOs()<span class="kom">// Vytvoøení VBO</span></p>
<p class="src0">{</p>
<p class="src1"><span class="kom">// VBO pro vertexy</span></p>
<p class="src1">glGenBuffersARB(1, &amp;m_nVBOVertices);<span class="kom">// Získání jména (ID)</span></p>
<p class="src1">glBindBufferARB(GL_ARRAY_BUFFER_ARB, m_nVBOVertices);<span class="kom">// Zvolení bufferu</span></p>
<p class="src1">glBufferDataARB(GL_ARRAY_BUFFER_ARB, m_nVertexCount * 3 * sizeof(float), m_pVertices, GL_STATIC_DRAW_ARB);</p>
<p class="src"></p>
<p class="src1"><span class="kom">// VBO pro texturové koordináty</span></p>
<p class="src1">glGenBuffersARB(1, &amp;m_nVBOTexCoords);<span class="kom">// Získání jména (ID)</span></p>
<p class="src1">glBindBufferARB(GL_ARRAY_BUFFER_ARB, m_nVBOTexCoords);<span class="kom">// Zvolení bufferu</span></p>
<p class="src1">glBufferDataARB(GL_ARRAY_BUFFER_ARB, m_nVertexCount * 2 * sizeof(float), m_pTexCoords, GL_STATIC_DRAW_ARB);</p>
<p class="src"></p>
<p class="src1"><span class="kom">// Data v RAM u¾ jsou zbyteèná</span></p>
<p class="src1">delete [] m_pVertices;</p>
<p class="src1">delete [] m_pTexCoords;</p>
<p class="src1">m_pVertices = NULL;</p>
<p class="src1">m_pTexCoords = NULL;</p>
<p class="src0">}</p>

<p>Tak to bychom mìli, teï je èas na inicializaci. Vytvoøíme dynamický objekt vý¹kové mapy a pokusíme se ji vygenerovat ze souboru terrain.bmp. Není-li nadefinovaná symbolická konstanta NO_VBOS, zjistíme, jestli grafická karta podporuje roz¹íøení GL_ARB_vertex_buffer_object. Pokud ano, pomocí wglGetProcAddress() nagrabujeme ukazatele na potøebné funkce a vytvoøíme VBO. V¹imnìte si, ¾e se ve funkci BuildVBOs() ma¾ou data vý¹kové mapy, která se volá pouze, pokud je VBO podporováno.</p>

<p class="src0">BOOL Initialize(GL_Window* window, Keys* keys)<span class="kom">// Inicializace</span></p>
<p class="src0">{</p>
<p class="src1">g_window = window;</p>
<p class="src1">g_keys = keys;</p>
<p class="src"></p>
<p class="src1">g_pMesh = new CMesh();<span class="kom">// Instance vý¹kové mapy</span></p>
<p class="src"></p>
<p class="src1">if(!g_pMesh-&gt;LoadHeightmap(&quot;terrain.bmp&quot;, MESH_HEIGHTSCALE, MESH_RESOLUTION))<span class="kom">// Nahrání</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Error Loading Heightmap&quot;, &quot;Error&quot;, MB_OK);</p>
<p class="src2">return false;</p>
<p class="src1">}</p>
<p class="src"></p>
<p class="src0">#ifndef NO_VBOS</p>
<p class="src1">g_fVBOSupported = IsExtensionSupported(&quot;GL_ARB_vertex_buffer_object&quot;);<span class="kom">// Test podpory VBO</span></p>
<p class="src"></p>
<p class="src1">if(g_fVBOSupported)<span class="kom">// Je roz¹íøení podporováno?</span></p>
<p class="src1">{</p>
<p class="src2"><span class="kom">// Ukazatele na GL funkce</span></p>
<p class="src2">glGenBuffersARB = (PFNGLGENBUFFERSARBPROC) wglGetProcAddress(&quot;glGenBuffersARB&quot;);</p>
<p class="src2">glBindBufferARB = (PFNGLBINDBUFFERARBPROC) wglGetProcAddress(&quot;glBindBufferARB&quot;);</p>
<p class="src2">glBufferDataARB = (PFNGLBUFFERDATAARBPROC) wglGetProcAddress(&quot;glBufferDataARB&quot;);</p>
<p class="src2">glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC) wglGetProcAddress(&quot;glDeleteBuffersARB&quot;);</p>
<p class="src"></p>
<p class="src2">g_pMesh-&gt;BuildVBOs();<span class="kom">// Poslat data vertexù do pamìti grafické karty</span></p>
<p class="src1">}</p>
<p class="src0">#else</p>
<p class="src1">g_fVBOSupported = false;<span class="kom">// Bez VBO</span></p>
<p class="src0">#endif</p>
<p class="src"></p>
<p class="src1"><span class="kom">// Klasické nastavení OpenGL</span></p>
<p class="src1">glClearColor(0.0f, 0.0f, 0.0f, 0.5f);</p>
<p class="src1">glClearDepth(1.0f);</p>
<p class="src1">glDepthFunc(GL_LEQUAL);</p>
<p class="src1">glEnable(GL_DEPTH_TEST);</p>
<p class="src1">glShadeModel(GL_SMOOTH);</p>
<p class="src1">glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);</p>
<p class="src1">glEnable(GL_TEXTURE_2D);</p>
<p class="src1">glColor4f(1.0f, 1.0f, 1.0f, 1.0f);</p>
<p class="src"></p>
<p class="src1">return TRUE;<span class="kom">// Inicializace úspì¹ná</span></p>
<p class="src0">}</p>

<p>Funkci IsExtensionSupported(), která zji¹»uje podporu roz¹íøení, mù¾ete získat na OpenGL.org, ale moje varianta je o trochu èist¹í. Nìkteøí lidé sice pomocí strstr() hledají pouze pøítomnost podøetìzce v øetìzci, nicménì zdá se, ¾e OpenGL.org moc nedùvìøuje konzistentnosti øetìzce s roz¹íøeními.</p>

<p class="src0">bool IsExtensionSupported(char* szTargetExtension)<span class="kom">// Je roz¹íøení podporováno?</span></p>
<p class="src0">{</p>
<p class="src1">const unsigned char *pszExtensions = NULL;</p>
<p class="src1">const unsigned char *pszStart;</p>
<p class="src1">unsigned char *pszWhere, *pszTerminator;</p>
<p class="src"></p>
<p class="src1"><span class="kom">// Jméno by nemìlo mít mezery</span></p>
<p class="src1">pszWhere = (unsigned char *)strchr(szTargetExtension, ' ');</p>
<p class="src"></p>
<p class="src1">if (pszWhere || *szTargetExtension == '\0')</p>
<p class="src1">{</p>
<p class="src2">return false;<span class="kom">// Nepodporováno</span></p>
<p class="src1">}</p>
<p class="src"></p>
<p class="src1">pszExtensions = glGetString(GL_EXTENSIONS);<span class="kom">// Øetìzec s názvy roz¹íøení</span></p>
<p class="src"></p>
<p class="src1"><span class="kom">// Vyhledávání podøetìzce se jménem roz¹íøení</span></p>
<p class="src1">pszStart = pszExtensions;</p>
<p class="src"></p>
<p class="src1">for (;;)</p>
<p class="src1">{</p>
<p class="src2">pszWhere = (unsigned char *) strstr((const char *) pszStart, szTargetExtension);</p>
<p class="src"></p>
<p class="src2">if (!pszWhere)</p>
<p class="src2">{</p>
<p class="src3">break;</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">pszTerminator = pszWhere + strlen(szTargetExtension);</p>
<p class="src"></p>
<p class="src2">if (pszWhere == pszStart || *(pszWhere - 1) == ' ')</p>
<p class="src2">{</p>
<p class="src3">if (*pszTerminator == ' ' || *pszTerminator == '\0')</p>
<p class="src3">{</p>
<p class="src4">return true;<span class="kom">// Podporováno</span></p>
<p class="src3">}</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">pszStart = pszTerminator;</p>
<p class="src1">}</p>
<p class="src"></p>
<p class="src1">return false;<span class="kom">// Nepodporováno</span></p>
<p class="src0">}</p>

<p>Vìt¹ina vìcí je u¾ hotová, zbývá vykreslování.</p>

<p class="src0">void Draw(void)<span class="kom">// Vykreslování</span></p>
<p class="src0">{</p>
<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</p>
<p class="src1">glLoadIdentity();</p>

<p>Existuje nìkolik mo¾ností, jak získat FPS. Asi nejjednodu¹¹í je èítat po dobu jedné sekundy prùchody vykreslovací funkcí.</p>

<p class="src1"><span class="kom">// Získání FPS</span></p>
<p class="src1">if(GetTickCount() - g_dwLastFPS &gt;= 1000)<span class="kom">// Ubìhla sekunda?</span></p>
<p class="src1">{</p>
<p class="src2">g_dwLastFPS = GetTickCount();<span class="kom">// Aktualizace èasu pro dal¹í mìøení</span></p>
<p class="src2">g_nFPS = g_nFrames;<span class="kom">// Ulo¾ení FPS</span></p>
<p class="src2">g_nFrames = 0;<span class="kom">// Reset èítaèe</span></p>
<p class="src"></p>
<p class="src2">char szTitle[256] = {0};<span class="kom">// Øetìzec titulku okna</span></p>
<p class="src2">sprintf(szTitle, &quot;Lesson 45: NeHe &amp; Paul Frazee's VBO Tut - %d Triangles, %d FPS&quot;, g_pMesh-&gt;m_nVertexCount / 3, g_nFPS);</p>
<p class="src"></p>
<p class="src2">if(g_fVBOSupported)<span class="kom">// Pou¾ívá/nepou¾ívá VBO</span></p>
<p class="src2">{</p>
<p class="src3">strcat(szTitle, &quot;, Using VBOs&quot;);</p>
<p class="src2">}</p>
<p class="src2">else</p>
<p class="src2">{</p>
<p class="src3">strcat(szTitle, &quot;, Not Using VBOs&quot;);</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">SetWindowText(g_window-&gt;hWnd, szTitle);<span class="kom">// Nastaví titulek</span></p>
<p class="src1">}</p>
<p class="src"></p>
<p class="src1">g_nFrames++;<span class="kom">// Inkrementace èítaèe FPS</span></p>

<p>Pøesuneme kameru nad terén a natoèíme scénu okolo osy y. Promìnnou g_flYRot inkrementujeme ve funkci Update().</p>

<p class="src1">glTranslatef(0.0f, -220.0f, 0.0f);<span class="kom">// Pøesun nad terén</span></p>
<p class="src1">glRotatef(10.0f, 1.0f, 0.0f, 0.0f);<span class="kom">// Naklonìní kamery</span></p>
<p class="src1">glRotatef(g_flYRot, 0.0f, 1.0f, 0.0f);<span class="kom">// Rotace kamery</span></p>

<p>Abychom mohli pracovat s vertex arrays (a také VBO), musíme zapnout GL_VERTEX_ARRAY a GL_TEXTURE_COORD_ARRAY. Proto¾e máme pouze jednu vý¹kovou mapu, nemuseli bychom to dìlat po ka¾dé, ale bývá to dobrým zvykem.</p>

<p class="src1">glEnableClientState(GL_VERTEX_ARRAY);<span class="kom">// Zapne vertex arrays</span></p>
<p class="src1">glEnableClientState(GL_TEXTURE_COORD_ARRAY);<span class="kom">// Zapne texture coord arrays</span></p>

<p>Dále musíme specifikovat pole, ve kterých má OpenGL hledat data. Zaènu nejprve vertex arrays (èást else), proto¾e jsou jednodu¹¹í. V¹e, co potøebujeme udìlat, je zavolání funkce glVertexPointer(), které se pøedává poèet prvkù na jeden vertex (2, 3 nebo 4), typ dat, prokládání (v pøípadì, ¾e nejsou vertexy v samostatné struktuøe) a ukazatel na pole. To samé platí i pro texturové koordináty, ale mají svoji vlastní funkci. Také bychom mohli ulo¾it v¹echna data do jednoho velkého pamì»ového bufferu a pou¾ít glInterleavedArrays(), ale necháme je oddìlené, abyste vidìli, jak pou¾ít více VBO najednou.</p>

<p>Jediný rozdíl mezi vertex arrays a VBO je na tomto místì pouze v tom, ¾e u VBO zavoláme glBindBufferARB() a do gl*Pointer() pøedáme místo ukazatele hodnotu NULL.</p>

<p class="src1">if(g_fVBOSupported)<span class="kom">// Podporuje grafická karta VBO?</span></p>
<p class="src1">{</p>
<p class="src2">glBindBufferARB(GL_ARRAY_BUFFER_ARB, g_pMesh-&gt;m_nVBOVertices);</p>
<p class="src2">glVertexPointer(3, GL_FLOAT, 0, (char *) NULL);<span class="kom">// Pøedat NULL</span></p>
<p class="src2">glBindBufferARB(GL_ARRAY_BUFFER_ARB, g_pMesh-&gt;m_nVBOTexCoords);</p>
<p class="src2">glTexCoordPointer(2, GL_FLOAT, 0, (char *) NULL);<span class="kom">// Pøedat NULL</span></p>
<p class="src1">}</p>
<p class="src1">else<span class="kom">// Obyèejné vertex arrays</span></p>
<p class="src1">{</p>
<p class="src2">glVertexPointer(3, GL_FLOAT, 0, g_pMesh-&gt;m_pVertices);<span class="kom">// Ukazatel na data vertexù</span></p>
<p class="src2">glTexCoordPointer(2, GL_FLOAT, 0, g_pMesh-&gt;m_pTexCoords);<span class="kom">// Ukazatel na texturové koordináty</span></p>
<p class="src1">}</p>

<p>Samotný rendering je je¹tì snaz¹í. Pomocí glDrawArrays() øekneme OpenGL, aby vykreslil trojúhelníky ve formátu GL_TRIANGLES. Jako poèáteèní index v poli pøedáme nulu, celkový poèet vertexù by mìl být jasný. Funkce pomocí client state sama detekuje, co v¹echno má pøi renderingu pou¾ít (textury, svìtlo...). Existuje mnohem více zpùsobù, jak poslat data OpenGL. Jako pøíklad uvedu glArrayElement(), ale na¹e verze je ze v¹ech nejrychlej¹í. V¹imnìte si také, ¾e nespecifikujeme ¾ádné glBegin() a glEnd(). Zde nejsou nutné.</p>

<p>Funkce glDrawArrays() je také dùvodem, proè jsem zvolil nesdílet jeden vertex mezi nìkolika trojúhelníky - není to mo¾né. co vím, nejlep¹í cestou, jak optimalizovat pamì»ové nároky, je pou¾ít triangle strip. V pøípadì svìtel byste mìli zajistit, aby mìl k sobì ka¾dý vertex odpovídající normálový vektor. Je to sice nutnost, bez které by tato funkce nefungovala, na druhou stranu se v¹ak obrovsky zlep¹í vzhled renderovaného objektu.</p>

<p class="src1">glDrawArrays(GL_TRIANGLES, 0, g_pMesh-&gt;m_nVertexCount);<span class="kom">// Vykreslení vertexù</span></p>

<p>Zbývá vypnout client state a máme hotovo.</p>

<p class="src1">glDisableClientState(GL_VERTEX_ARRAY);<span class="kom">// Vypne vertex arrays</span></p>
<p class="src1">glDisableClientState(GL_TEXTURE_COORD_ARRAY);<span class="kom">// Vypne texture coord arrays</span></p>
<p class="src0">}</p>

<p>Pokud byste chtìli získat více informací o vertex buffer object, doporuèuji prostudovat si dokumentaci ve SGI registru roz¹íøení (SGI's extensions registry) na <?OdkazBlank('http://oss.sgi.com/projects/ogl-sample/registry/');?>. Je to sice trochu tì¾¹í ètení ne¾ tento tutoriál, ale budete znát mnohem více mo¾ností implementace a detailù.</p>

<p class="autor">napsal: Paul Frazee <?VypisEmail('paulfrazee@cox.net');?><br />
pøelo¾il: Michal Turek - Woq <?VypisEmail('woq@email.cz');?></p>

<h3 class="zdroj_kody_nadpis">Zdrojové kódy</h3>

<ul class="zdroj_kody">
<li><a href="http://nehe.gamedev.net/data/lessons/vc/lesson45.zip">Visual C++</a> kód této lekce.</li>
<li><a href="http://nehe.gamedev.net/data/lessons/bcb6/lesson45_bcb6.zip">Borland C++ Builder 6</a> kód této lekce. ( <a href="mailto:conglth@hotmail.com">Le Thanh Cong</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/cwarrior/lesson45.zip">Code Warrior 5.3</a> kód této lekce. ( <a href="mailto:DelusionalBeing@hotmail.com">Scott Lupton</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/devc/lesson45.zip">Dev C++</a> kód této lekce. ( <a href="mailto:gery.buchgraber@gmx.de">Gerald Buchgraber</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/vs_net/lesson45.zip">Visual Studio .NET</a> kód této lekce. ( <a href="mailto:webmaster@joachimrohde.de">Joachim Rohde</a> )</li>
</ul>

<?FceImgNeHeVelky(45);?>
<?FceNeHeOkolniLekce(45);?>

<?
include 'p_end.php';
?>
