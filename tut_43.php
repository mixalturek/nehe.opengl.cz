<?
$g_title = 'CZ NeHe OpenGL - Lekce 43 - FreeType Fonty v OpenGL';
$g_description = 'NeHe OpenGL Tutoriály v èe¹tinì, programování 3D grafiky, èlánky, programy se zdrojovými kódy...';
$g_keywords = 'opengl, nehe, tutoriály, woq, programování, 3D';

include 'p_begin.php';
?>

<?FceImgNeHeMaly(43);?>

<h1>Lekce 43 - FreeType Fonty v OpenGL</h1>

<p class="nadpis_clanku">Pou¾itím knihovny FreeType Font rendering library mù¾ete snadno vypisovat vyhlazené znaky, které vypadají mnohem lépe ne¾ písmena u bitmapových fontù z lekce 13. Ná¹ text bude mít ale i jiné výhody - bezproblémová rotace, dobrá spolupráce s OpenGL vybíracími (picking) funkcemi a víceøádkové øetìzce.</p>

<p class="netisk"><a href="tut_43_sk.php">Verze ve sloven¹tinì...</a></p>

<p>Motivace: Tady máte ukázky bitmapového fontu vytvoøeného pomocí WGL a FreeType fontu. Oba jsou Arial Black Kurzíva.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_43_foo_foo.gif" width="158" height="37" alt="FreeType font a WGL font" /></div>

<p>Základní problém s pou¾itím bitmapových fontù je, ¾e OpenGL bitmapy jsou binárními obrázky. To znamená, ¾e si OpenGL pamatuje pouze 1 bit na 1 pixel. Zoomujeme-li na text vytvoøený pomocí WGL, výsledek vypadá pøibli¾nì takto:</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_43_wgl.gif" width="185" height="85" alt="Zvìt¹ený WGL font" /></div>

<p>Proto¾e jsou bitmapy binární obrázky, nejsou okolo nich ¹edé pixely a to znamená, ¾e vypadají hùø. Na¹tìstí je velmi jednoduché pomocí GNU FreeType knihovny vytvoøit dobøe vypadající fonty. Tuto knihovnu pou¾ívá i Blizzard ve svých hrách, tak¾e musí být opravdu dobrá :-))). Opìt ukázka zvìt¹eného textu, tentokrát s knihovnou FreeType:</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_43_free.gif" width="196" height="85" alt="Zvìt¹ený FreeType font" /></div>

<p>Jak mù¾eme vidìt, okolo okrajù se nachází spousta ¹edých pixelù, které jsou typické pro vyhlazené (anti-aliasované) fonty. ©edé pixely vylep¹ují znaky pøi pohledu z dálky.</p>

<p>Knihovnu GNU FreeType si mù¾ete stáhnout na adrese <?OdkazBlank('http://gnuwin32.sourceforge.net/packages/freetype.htm');?>. Konkrétnì se jedná o binární a vývojáøské soubory. Pøi instalaci si urèitì v¹imnete licenèní podmínky. Hovoøí se v ní, ¾e pøi pou¾ití ve vlastních programech, musíte nìkde v dokumentaci uvést kredit.</p>

<p>Po instalaci potøebujeme nastavit MSVC, aby umìlo pou¾ívat FreeType. V menu Project - Settings - Link se ujistìte, ¾e jste spolu s opengl32.lib, glu32.lib, glaux.lib a podobnými pøidali do Object/libraries i libfreetype.lib.</p>

<p>Dále potøebujeme v Tools - Options - Directories pøidat cesty k hlavièkových souborùm. Pod Show Directories for vybereme Include Files a poklikáme na prázdný øádek dole v seznamu. Objeví se tlaèítko se tøemi teèkami, které pou¾ijeme pro výbìr adresáøe. Takto pøidáme:</p>

<p class="src0">C:\PROGRAM FILES\GNUWIN32\INCLUDE\FREETYPE32</p>

<p>a</p>

<p class="src0">C:\PROGRAM FILES\GNUWIN\INCLUDE</p>

<p>Pod Show Directories For vybereme Library Files a pøidáme</p>

<p class="src0">C:\PROGRAM FILES\GNUWIN32\LIB</p>

<p>Na tomto místì bychom mìli být schopni kompilovat programy, které pou¾ívají FreeType, ale nepùjdou spustit bez dynamické knihovny freetype-6.dll. Kopii tohoto souboru naleznete v GNUWIN32\BIN. Je tøeba ji umístit do adresáøe, ve kterém systém pøi spou¹tìní programù knihovny hledá (napø. C:\PROGRAM FILES\MICROSOFT\VISUAL STUDIO\VC98\BIN nebo C:\WINDOWS\SYSTEM pro WIN9x, C:\WINNT\SYSTEM32 pro WIN NT/2000/XP). Pøekl.: Osobnì doporuèuji podobné DLL knihovny výhradnì vkládat do adresáøe, ve kterém se nachází spoustìný exe soubor, proto¾e a¾ budete vá¹ program nìkomu kopírovat, nikdy na nì nezapomenete (Tak ten tvùj program mi ne¹el spustit!).</p>

<p>OK, tak teï u¾ koneènì mù¾eme zaèít programovat. Jako základ vezmeme lekci 13. Zkopírujeme soubor lesson13.cpp a pøidáme ho do projektu. Stejnì tak zkopírujeme dva nové soubory freetype.h a freetype.cpp, do kterých budeme pøidávat v¹echen FreeTypový kód. A¾ skonèíme, budeme mít jednoduchou FreeType knihovnu, kterou budeme moci vyu¾ít i v jiných OpenGL programech.</p>

<p>Zaèneme vytváøením freetype.h. Samozøejmì musíme nadefinovat hlavièky FreeType a OpenGL. Také pøidáme pár u¾iteèných èástí ze Standard Template Library (STL). Konkrétnì se jedná o tøídy vyjímek, které nám zjednodu¹í vytváøení pìkných debugových zpráv. Pou¾ití STL zvy¹uje ¹anci, ¾e nìkdo jiný, kdo pou¾ívá ná¹ kód, úspì¹nì zachytí v¹echny poslané vyjímky.</p>

<p class="src0">#ifndef FREE_NEHE_H</p>
<p class="src0">#define FREE_NEHE_H</p>
<p class="src"></p>
<p class="src0">#include &lt;windows.h&gt;</p>
<p class="src"></p>
<p class="src0"><span class="kom">// FreeType hlavièky</span></p>
<p class="src0">#include &lt;ft2build.h&gt;</p>
<p class="src0">#include &lt;freetype/freetype.h&gt;</p>
<p class="src0">#include &lt;freetype/ftglyph.h&gt;</p>
<p class="src0">#include &lt;freetype/ftoutln.h&gt;</p>
<p class="src0">#include &lt;freetype/fttrigon.h&gt;</p>
<p class="src"></p>
<p class="src0"><span class="kom">// OpenGL hlavièky</span></p>
<p class="src0">#include &lt;GL/gl.h&gt;</p>
<p class="src0">#include &lt;GL/glu.h&gt;</p>
<p class="src"></p>
<p class="src0"><span class="kom">// STL hlavièky</span></p>
<p class="src0">#include &lt;vector&gt;</p>
<p class="src0">#include &lt;string&gt;</p>
<p class="src"></p>
<p class="src0"><span class="kom">// STL vyjímky</span></p>
<p class="src0">#include &lt;stdexcept&gt;</p>

<p>Následující pragma MSVC zabrání, aby oznamovalo zbyteèná varování o vektorech øetìzcù.</p>

<p class="src0">#pragma warning(disable: 4786)</p>

<p>V¹echny informace, které ka¾dý font potøebuje, dáme do jedné struktury (toto ulehèí práci s více písmy). Jak jsme se nauèili v lekci 13, kdy¾ WGL vytváøí font, generuje sadu display listù s postupnì se zvy¹ujícím ID. To je ¹ikovné, proto¾e díky tomu mù¾eme pro vypsání celého øetìzce pou¾ít jediný pøíkaz glCallLists(). V na¹í knihovnì nastavíme v¹echno úplnì stejnì, co¾ znamená, ¾e pole list_base bude ukládat prvních 128 display listù jednotlivých znakù. Proto¾e se chystáme pro vykreslování pou¾ít textury, potøebujeme také ulo¾it 128 asociovaných textur. Poslední, co udìláme, je deklarování promìnné oznaèující vý¹ku vytváøeného fontu v pixelech, která nám umo¾ní vypisovat i zalomení øádkù oznaèené \n v øetìzci.</p>

<p class="src0">namespace freetype<span class="kom">// Proti vícenásobnému pou¾ití stejných identifikátorù</span></p>
<p class="src0">{</p>
<p class="src1">using std::vector;<span class="kom">// Mo¾nost psát jen vector namísto std::vector</span></p>
<p class="src1">using std::string;<span class="kom">// To samé pro string</span></p>
<p class="src"></p>
<p class="src1">struct font_data<span class="kom">// Zapouzdøení v¹eho do struktury</span></p>
<p class="src1">{</p>
<p class="src2">float h;<span class="kom">// Vý¹ka fontu</span></p>
<p class="src2">GLuint* textures;<span class="kom">// ID textur</span></p>
<p class="src2">GLuint list_base;<span class="kom">// ID prvního display listu</span></p>
<p class="src"></p>
<p class="src2">void init(const char* fname, unsigned int h);<span class="kom">// Vytvoøení písma s vý¹kou h ze souboru fname</span></p>
<p class="src2">void clean();<span class="kom">// Uvolnìní v¹ech prostøedkù spojených s fontem</span></p>
<p class="src1">};</p>

<p>Funkce print() vykreslí zadaný text na souøadnicích x, y. Modelview matice bude také aplikovaná na text.</p>

<p class="src1">void print(const font_data &amp;ft_font, float x, float y, const char *fmt, ...);<span class="kom">// Vykreslí text</span></p>
<p class="src0">}</p>
<p class="src"></p>
<p class="src0">#endif</p>

<p>To je konec hlavièkového souboru freetype.h, teï otevøeme freetype.cpp.</p>

<p class="src0">#include &quot;freetype.h&quot;<span class="kom">// Vlo¾í freetype.h</span></p>
<p class="src"></p>
<p class="src0">namespace freetype</p>
<p class="src0">{</p>

<p>Pro vykreslení znakù budeme pou¾ívat textury, které musí samozøejmì mít rozmìry mocniny èísla 2. Následující funkce vrátí první mocninu dvojky, která se rovná nebo je vìt¹í ne¾ pøedané èíslo.</p>

<p class="src1">inline int next_p2(int a)<span class="kom">// Vrátí následující mocninu èísla 2</span></p>
<p class="src1">{</p>
<p class="src2">int rval = 1;<span class="kom">// Nastaví bit vpravo do jednièky</span></p>
<p class="src"></p>
<p class="src2">while(rval &lt; a)<span class="kom">// Dokud je nalezená mocnina men¹í ne¾ minimum</span></p>
<p class="src2">{</p>
<p class="src3">rval &lt;&lt;= 1;<span class="kom">// Získání dal¹í mocniny (rotace bitù doleva, rychlej¹í zpùsob, jak napsat rval *= 2)</span></p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">return rval;<span class="kom">// Vrácení výsledku</span></p>
<p class="src1">}</p>

<p>Dal¹í funkce, kterou budeme potøebovat, je srdcem tohoto kódu. Make_dlist() vytvoøí display list podle poslaného znaku, parametr FT_Face pøedstavuje objekt, který FreeType pou¾ívá pro uchování informací o fontu. Funkci se dále pøedává ID základního display listu a ukazatel na texturu.</p>

<p class="src1">void make_dlist(FT_Face face, char ch, GLuint list_base, GLuint* tex_base)<span class="kom">// Vytvoøí display list pro daný znak</span></p>
<p class="src1">{</p>

<p>Na zaèátku po¾ádáme FreeType o vykreslení daného znaku do bitmapy.</p>

<p class="src2">if(FT_Load_Glyph(face, FT_Get_Char_Index(face, ch), FT_LOAD_DEFAULT))<span class="kom">// Naète glyph znaku</span></p>
<p class="src2">{</p>
<p class="src3">throw std::runtime_error(&quot;FT_Load_Glyph failed&quot;);</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">FT_Glyph glyph;<span class="kom">// Glyph objekt</span></p>
<p class="src"></p>
<p class="src2">if(FT_Get_Glyph(face-&gt;glyph, &amp;glyph))<span class="kom">// Pøesun glyphu do glyph objektu</span></p>
<p class="src2">{</p>
<p class="src3">throw std::runtime_error(&quot;FT_Get_Glyph failed&quot;);</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">FT_Glyph_To_Bitmap(&amp;glyph, ft_render_mode_normal, 0, 1);<span class="kom">// Konvertování glyphu na bitmapu</span></p>
<p class="src2">FT_BitmapGlyph bitmap_glyph = (FT_BitmapGlyph)glyph;</p>
<p class="src"></p>
<p class="src2">FT_Bitmap&amp; bitmap = bitmap_glyph-&gt;bitmap;<span class="kom">// Reference ulehèí pøístup k bitmapì</span></p>

<p>Teï, kdy¾ máme pomocí FreeType vytvoøenu bitmapu, potøebujeme do ní doplnit prázdné pixely, abychom ji mohli pou¾ít v OpenGL. Je dùle¾ité zapamatovat si, ¾e zatímco OpenGL pou¾ívá termín bitmapa k oznaèení binárních obrázkù, ve FreeType bitmapa ukládá 8 bitù informace na pixel, tak¾e mù¾e ukládat i ¹edé slo¾ky, které jsou potøebné pro vyhlazený text.</p>

<p class="src2">int width = next_p2(bitmap.width);<span class="kom">// Velikost textury - mocnina èísla 2</span></p>
<p class="src2">int height = next_p2(bitmap.rows);</p>
<p class="src"></p>
<p class="src2">GLubyte* expanded_data = new GLubyte[2 * width * height];<span class="kom">// Alokace pamìti</span></p>

<p>V¹imnìte si, ¾e pou¾íváme dvoukanálovou bitmapu, první kanál pro záøivost a druhý pro alfu. Oba pøiøadíme hodnotì, kterou jsme nalezli ve FreeType bitmapì. Ternální operátor ? : pou¾ijeme pro urèení nulové hodnoty, pokud se nacházíme v okrajové zónì (zvìt¹ení pro mocninu 2), v ostatních pøípadech platí hodnota pøevzatá z FreeType bitmapy.</p>

<p class="src2">for(int j = 0; j &lt; height; j++)</p>
<p class="src2">{</p>
<p class="src3">for(int i = 0; i &lt; width; i++)</p>
<p class="src3">{</p>
<p class="src4">expanded_data[2 * (i + j*width)] = expanded_data[2 * (i + j*width) + 1] = (i &gt;= bitmap.width || j &gt;= bitmap.rows) ? 0 : bitmap.buffer[i + bitmap.width*j];</p>
<p class="src3">}</p>
<p class="src2">}</p>

<p>Jsme hotovi, tak¾e se mù¾eme pustit do vytváøení OpenGL textury. Proto¾e zahrneme alfa kanál, èerné èásti bitapy budou v¾dy prùhledné a okraje textu budou plynule prùsvitné. Text by mìl vypadat správnì na jakémkoli podkladì. Jak u¾ jsem napsal, texturu vytváøíme ze slo¾ek luminance a alfa.</p>

<p class="src2"><span class="kom">// Nastavení parametrù textury</span></p>
<p class="src2">glBindTexture(GL_TEXTURE_2D, tex_base[ch]);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</p>
<p class="src"></p>
<p class="src2">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, expanded_data);</p>
<p class="src"></p>
<p class="src2">delete [] expanded_data;<span class="kom">// Uvolnìní pamìti bitmapy</span></p>

<p>Na vykreslení znaku pou¾ijeme otexturované ètyøúhelníky. To znamená, ¾e bude jednoduché otáèet, zvìt¹ovat i zmen¹ovat text a dokonce bude od OpenGL dìdit barvu.</p>

<p class="src2">glNewList(list_base + ch, GL_COMPILE);<span class="kom">// Vytvoøení display listu</span></p>
<p class="src3">glBindTexture(GL_TEXTURE_2D, tex_base[ch]);</p>

<p>Nejdøív pohneme kamerou trochu doprava, aby byl znak vycentrovaný mezi minulým a následujícím. Ulo¾íme matici a pokud pracujeme se znakem typu g nebo y, posuneme se trochu dolù.</p>

<p class="src3">glTranslatef(bitmap_glyph-&gt;left, 0, 0);<span class="kom">// Vycentrování znaku mezi minulým a následujícím</span></p>
<p class="src"></p>
<p class="src3">glPushMatrix();</p>
<p class="src4">glTranslatef(0, bitmap_glyph-&gt;top - bitmap.rows, 0);<span class="kom">// Posun o trochu dolù</span></p>

<p>Musíme poèítat s faktem, ¾e mnoho textur je na okraji vyplnìných prázdným místem. Zjistíme, jaká èást textury je znakem pou¾ívána a tuto hodnotu ulo¾íme do pomocných promìnných x a y, kterou pøed kreslením pøedáme funkci glTexCoord2d().</p>

<p class="src4">float x = (float)bitmap.width / (float)width;</p>
<p class="src4">float y = (float)bitmap.rows / (float)height;</p>

<p>Na tomto místì vykreslíme otexturovaný obdélník. Bitmapa, kterou jsme získali pomocí FreeType není orientovaná pøesnì tak, jak by mìla, ale to nám nevadí, proto¾e mù¾eme explicitnì urèit polohu pro správné zarovnání.</p>

<p class="src4">glBegin(GL_QUADS);<span class="kom">// Vykreslení znaku</span></p>
<p class="src5">glTexCoord2d(0, 0); glVertex2f(0, bitmap.rows);</p>
<p class="src5">glTexCoord2d(0, y); glVertex2f(0, 0);</p>
<p class="src5">glTexCoord2d(x, y); glVertex2f(bitmap.width, 0);</p>
<p class="src5">glTexCoord2d(x, 0); glVertex2f(bitmap.width, bitmap.rows);</p>
<p class="src4">glEnd();</p>
<p class="src3">glPopMatrix();</p>
<p class="src"></p>
<p class="src3">glTranslatef(face-&gt;glyph-&gt;advance.x &gt;&gt; 6, 0, 0);</p>

<p>Inkrementujeme pozici v rastru stejnì, jako bychom pracovali s bitmapovým fontem. To je nutné pouze, pokud bychom chtìli spoèítat aktuální délku textu. Proto jsem øádek zakomentoval.</p>

<p class="src3"><span class="kom">// glBitmap(0, 0, 0, 0, face->glyph->advance.x &gt;&gt; 6, 0, NULL);</span></p>
<p class="src"></p>
<p class="src2">glEndList();<span class="kom">// Ukonèíme display list</span></p>
<p class="src1">}</p>

<p>Dal¹í funkce, kterou se chystáme vytvoøit, bude pou¾ívat make_dlist() pro vytvoøení mno¾iny display listù odpovídajících danému souboru s fontem a vý¹ce v pixelech. FreeType pou¾ívá truetype fonty, tak¾e budeme potøebovat nìjaký .ttf soubor s fontem. Truetypová písma jsou velmi bì¾ná, existuje spousta míst na internetu, kde si je mù¾ete stáhnout. Jednodu¹¹í bude ale podívat se do adresáøe windows/fonts.</p>

<p class="src1">void font_data::init(const char * fname, unsigned int h)<span class="kom">// Vytvoøení fontu</span></p>
<p class="src1">{</p>
<p class="src2">textures = new GLuint[128];<span class="kom">// Pamì» pro ID textur</span></p>
<p class="src"></p>
<p class="src2">this-&gt;h = h;</p>
<p class="src"></p>
<p class="src2">FT_Library library;<span class="kom">// Vytvoøení FreeType</span></p>
<p class="src"></p>
<p class="src2">if (FT_Init_FreeType(&amp;library))<span class="kom">// Inicializace FreeType</span></p>
<p class="src2">{</p>
<p class="src3">throw std::runtime_error(&quot;FT_Init_FreeType failed&quot;);</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">FT_Face face;<span class="kom">// Objekt pro informace o fontu</span></p>

<p>Na tomto místì se pokusíme naèíst ze souboru data fontu. Ze v¹ech míst, kde se kód mù¾e zaseknout je právì toto nejèastìj¹í, proto¾e soubor napø. nemusí existovat nebo mù¾e být nìjakým zpùsobem po¹kozen.</p>

<p class="src2">if (FT_New_Face(library, fname, 0, &amp;face))<span class="kom">// Naètení fontu ze souboru</span></p>
<p class="src2">{</p>
<p class="src3">throw std::runtime_error(&quot;FT_New_Face failed (there is probably a problem with your font file)&quot;);</p>
<p class="src2">}</p>

<p>Z nìjakým nevysvìtlitelných dùvodù mìøí FreeType velikost písma v 1/64-nách pixelù. Proto, abychom mìli font vysoký h pixelù, musíme pøedávat velikost násobenou èíslem 64. H &lt;&lt; 6 je jen rychlej¹í zpùsob psaní této operace.</p>

<p class="src2">FT_Set_Char_Size(face, h &lt;&lt; 6, h &lt;&lt; 6, 96, 96);</p>

<p>Pøekl.: Anglické znakové sadì staèí pouze 128 znakù, ale èe¹tina obsahuje navíc háèky a èárky, tak¾e pokud je chcete pou¾ívat, musíte upravit kód.</p>

<p class="src2">list_base = glGenLists(128);<span class="kom">// 128 display listù a textur</span></p>
<p class="src2">glGenTextures(128, textures);</p>
<p class="src"></p>
<p class="src2">for(unsigned char i = 0; i &lt; 128; i++)<span class="kom">// Vytvoøení display listù znakù</span></p>
<p class="src2">{</p>
<p class="src3">make_dlist(face, i, list_base, textures);</p>
<p class="src2">}</p>

<p>Proto¾e v¹echna data máme ulo¾ena v display listech a texturách, mù¾eme uvolnit pou¾ité zdroje FreeType.</p>

<p class="src2">FT_Done_Face(face);<span class="kom">// Uvolnìní zdrojù</span></p>
<p class="src2">FT_Done_FreeType(library);</p>
<p class="src1">}</p>

<p>Vytvoøíme clean() funkci, která uvolní v¹echny prostøedky spojené s display listy a texturami.</p>

<p class="src1">void font_data::clean()</p>
<p class="src1">{</p>
<p class="src2">glDeleteLists(list_base, 128);</p>
<p class="src2">glDeleteTextures(128, textures);</p>
<p class="src2">delete [] textures;</p>
<p class="src1">}</p>

<p>Následují dvì pomocné funkce pro print(), která bude chtít operovat ne v OpenGL jednotkách, ale v pixelových souøadnicích okna. Nula se bude nacházet v levém horním rohu.</p>

<p class="src1">inline void pushScreenCoordinateMatrix()<span class="kom">// Pøepne do pravoúhlé projekce</span></p>
<p class="src1">{</p>
<p class="src2">glPushAttrib(GL_TRANSFORM_BIT);</p>
<p class="src2">GLint viewport[4];</p>
<p class="src2">glGetIntegerv(GL_VIEWPORT, viewport);</p>
<p class="src2">glMatrixMode(GL_PROJECTION);</p>
<p class="src2">glPushMatrix();</p>
<p class="src2">glLoadIdentity();</p>
<p class="src2">gluOrtho2D(viewport[0], viewport[2], viewport[1], viewport[3]);</p>
<p class="src2">glPopAttrib();</p>
<p class="src1">}</p>
<p class="src"></p>
<p class="src1">inline void pop_projection_matrix()<span class="kom">// Obnoví perspektivu</span></p>
<p class="src1">{</p>
<p class="src2">glPushAttrib(GL_TRANSFORM_BIT);</p>
<p class="src2">glMatrixMode(GL_PROJECTION);</p>
<p class="src2">glPopMatrix();</p>
<p class="src2">glPopAttrib();</p>
<p class="src1">}</p>

<p>Nová funkce print() vypadá velmi podobnì jako ta z lekce 13, ale je tu pár rozdílù. Nastavíme jiné OpenGL flagy, proto¾e pou¾íváme pouze dvoukanálové textury namísto bitmap. Abychom zajistili pøechody na nové øádky, pøidáme nìkolik extra výpoètù a samozøejmì nesmíme zapomenout na zaji¹tìní toho, aby v¹echna nastavení byla po výstupu z funkce ve stejné stavu jako pøed vstupem.</p>

<p class="src1">void print(const font_data &amp;ft_font, float x, float y, const char *fmt, ...)<span class="kom">// Rendering textu</span></p>
<p class="src1">{</p>
<p class="src2">pushScreenCoordinateMatrix();<span class="kom">// Souøadná soustava v pixelech</span></p>
<p class="src2"></p>
<p class="src2">GLuint font = ft_font.list_base;</p>
<p class="src2">float h = ft_font.h / 0.63f;<span class="kom">// Vìt¹í mezera mezi øádky</span></p>
<p class="src2"></p>
<p class="src2">char text[256];<span class="kom">// Výsledný øetìzec</span></p>
<p class="src2">va_list ap;<span class="kom">// Ukazatel na argumenty funkce</span></p>
<p class="src"></p>
<p class="src2">if (fmt == NULL)<span class="kom">// Byl pøedán text?</span></p>
<p class="src2">{</p>
<p class="src3">*text = 0;<span class="kom">// Nic nedìlat</span></p>
<p class="src2">}</p>
<p class="src2">else</p>
<p class="src2">{</p>
<p class="src3">va_start(ap, fmt);<span class="kom">// Analýza øetìzce na promìnné</span></p>
<p class="src4">vsprintf(text, fmt, ap);<span class="kom">// Konvertování symbolù na èísla</span></p>
<p class="src3">va_end(ap);<span class="kom">// Výsledky jsou ulo¾eny do text</span></p>
<p class="src2">}</p>

<p>Následující kód rozdìlí daný text na sadu øádkù. Velmi jednodu¹e by se to dalo provést pomocí regulárních výrazù, jedna taková knihovna je dostupná napø. na boost.org, ale my nic takového pou¾ívat nebudeme - jednodu¹e se sna¾ím udr¾et kód bez zbyteèných závislostí na ménì nutných knihovnách.</p>

<p class="src2"><span class="kom">// Rozdìlení øetìzce na jednotlivé øádky</span></p>
<p class="src2">const char *start_line = text;</p>
<p class="src2">vector&lt;string&gt; lines;</p>
<p class="src"></p>
<p class="src2">for(const char *c = text; *c; c++)</p>
<p class="src2">{</p>
<p class="src3">if(*c == '\n')</p>
<p class="src3">{</p>
<p class="src4">string line;</p>
<p class="src"></p>
<p class="src4">for(const char *n = start_line; n &lt; c; n++)</p>
<p class="src4">{</p>
<p class="src5">line.append(1, *n);</p>
<p class="src4">}</p>
<p class="src"></p>
<p class="src4">lines.push_back(line);</p>
<p class="src4">start_line = c + 1;</p>
<p class="src3">}</p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">if(start_line)</p>
<p class="src2">{</p>
<p class="src3">string line;</p>
<p class="src3">for(const char *n = start_line; n &lt; c; n++)</p>
<p class="src3">{</p>
<p class="src4">line.append(1, *n);</p>
<p class="src3">}</p>
<p class="src"></p>
<p class="src3">lines.push_back(line);</p>
<p class="src2">}</p>

<p>Zálohujeme v¹echny OpenGL parametry a potom je nastavíme na nutné hodnoty.</p>

<p class="src2">glPushAttrib(GL_LIST_BIT | GL_CURRENT_BIT  | GL_ENABLE_BIT | GL_TRANSFORM_BIT);</p>
<p class="src"></p>
<p class="src2">glMatrixMode(GL_MODELVIEW);</p>
<p class="src2">glDisable(GL_LIGHTING);</p>
<p class="src2">glEnable(GL_TEXTURE_2D);</p>
<p class="src2">glDisable(GL_DEPTH_TEST);</p>
<p class="src2">glEnable(GL_BLEND);</p>
<p class="src2">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</p>
<p class="src"></p>
<p class="src2">glListBase(font);</p>

<p>V¹echny transformace, které provedeme na modelview matici pøed voláním této funkce, se projeví i na textu samotném. To znamená, ¾e pøi výpisu textu máme mo¾nost rotovat nebo mìnit jeho velikost. Nejpøirozenìj¹í cestou by bylo ponechat pùvodní matici, tak jak byla, ale to nebude pracovat, proto¾e chceme mít kontrolu nad pozicí textu. Dal¹í mo¾ností by bylo vytvoøit kopii matice a mezi glTranslatef() a glCallLists() ji aplikovat, nicménì mìøítko projekèní matice teï u¾ není v OpenGL jednotkách, ale v pixelech, tak¾e bychom získali tro¹ku odli¹ný efekt, ne¾ by nìkdo mohl oèekávat. Pøes toto bychom se také mohli dostat neresetován projekèní matice uvnitø print(). To je v nìkterých situacích docela dobrý nápad, ale pokud to budete zkou¹et, zajistìte, ¾e fonty budou mít odpovídající velikost (jsou nastaveny na 32x32, ale vy pravdìpodobnì budete potøebovat nìco kolem 0,01x0,01). Zkuste uhodnout, kterou cestou jdeme my :-)</p>

<p class="src2">float modelview_matrix[16];</p>
<p class="src2">glGetFloatv(GL_MODELVIEW_MATRIX, modelview_matrix);</p>

<p>Zobrazování textu se dìje právì na tomto místì. Pro ka¾dý øádek resetujeme matici, aby zaèínal na správné pozici. V¹imnìte si, ¾e místo posunu dolù o vý¹ku h, ji radìji rovnou resetujeme. To proto, ¾e se pøi vykreslení ka¾dého znaku posouváme doprava na pozici znaku za ním.</p>

<p class="src2">for(int i = 0; i &lt; lines.size(); i++)<span class="kom">// Prochází jednotlivé øádky textu</span></p>
<p class="src2">{</p>
<p class="src3">glPushMatrix();<span class="kom">// Záloha matice</span></p>
<p class="src3">glLoadIdentity();<span class="kom">// Resetování matice</span></p>
<p class="src3">glTranslatef(x, y - h*i, 0);<span class="kom">// Pøesun na odpovídající pozici</span></p>
<p class="src3">glMultMatrixf(modelview_matrix);</p>

<p>Pokud byste potøebovali zjistit délku textu, který vytváøíte odkomentujete následující øádky. Pokud se tak rozhodnete, musíte odkomentovat i pøíkaz glBitmap() v make_dlist().</p>

<p class="src3"><span class="kom">// glRasterPos2f(0, 0);</span></p>
<p class="src"></p>
<p class="src3">glCallLists(lines[i].length(), GL_UNSIGNED_BYTE, lines[i].c_str());<span class="kom">// Vykreslí øádek textu</span></p>
<p class="src"></p>
<p class="src3"><span class="kom">// float rpos[4];</span></p>
<p class="src3"><span class="kom">// glGetFloatv(GL_CURRENT_RASTER_POSITION, rpos);</span></p>
<p class="src3"><span class="kom">// float len = x - rpos[0];</span></p>
<p class="src"></p>
<p class="src3">glPopMatrix();<span class="kom">// Obnovení matice</span></p>
<p class="src2">}</p>
<p class="src"></p>
<p class="src2">glPopAttrib();<span class="kom">// Obnovení OpenGL flagù</span></p>
<p class="src"></p>
<p class="src2">pop_projection_matrix();<span class="kom">// Obnovení perspektivy</span></p>
<p class="src1">}</p>
<p class="src0">}<span class="kom">// Konec namespace</span></p>

<p>Knihovna je teï kompletní. Abychom mohli vidìt výsledek, otevøeme soubor lesson13.cpp a provedeme v nìm nìkolik men¹ích zmìn. Za includování hlavièkových souborù vlo¾te i freetype.h.</p>

<p class="src0">#include &quot;freetype.h&quot;<span class="kom">// Vlo¾ení freetype</span></p>

<p>A kdy¾ u¾ jsme tu, deklarujeme i globální objekt font_data.</p>

<p class="src0">freetype::font_data our_font;<span class="kom">// Informace pro vytváøený font</span></p>

<p>Dále potøebujeme font inicializovat...</p>

<p class="src0"><span class="kom">// InitGL()</span></p>
<p class="src1">our_font.init(&quot;test.TTF&quot;, 16);<span class="kom">// Vytvoøení fontu</span></p>

<p>... a pøi skonèení programu odstranit.</p>

<p class="src0"><span class="kom">// KillGLWindow()</span></p>
<p class="src1">our_font.clean();</p>

<p>Do funkce DrawGLScene() doplníme výpis FreeType fontu, který bude navíc rotovat a mìnit svou velikost.</p>

<p class="src0">int DrawGLScene(GLvoid)<span class="kom">// V¹echno vykreslování</span></p>
<p class="src0">{</p>
<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="kom">// Smazání bufferù</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>
<p class="src"></p>
<p class="src1">glTranslatef(0.0f, 0.0f, -1.0f);<span class="kom">// Posun o jednotku do obrazovky</span></p>
<p class="src1">glColor3ub(0, 0, 0xff);<span class="kom">// Modrý text</span></p>
<p class="src"></p>
<p class="src1"><span class="kom">// Vykreslení WGL textu</span></p>
<p class="src1">glRasterPos2f(-0.40f, 0.35f);</p>
<p class="src1">glPrint(&quot;Active WGL Bitmap Text With NeHe - %7.2f&quot;, cnt1);</p>
<p class="src"></p>
<p class="src1"><span class="kom">// Vykreslení FreeType fontu</span></p>
<p class="src"></p>
<p class="src1">glColor3ub(0xff,0,0);<span class="kom">// Èervený text</span></p>
<p class="src"></p>
<p class="src1">glPushMatrix();</p>
<p class="src1">glLoadIdentity();</p>
<p class="src1">glRotatef(cnt1, 0, 0, 1);</p>
<p class="src1">glScalef(1, 0.8 + 0.3 * cos(cnt1 / 5), 1);</p>
<p class="src1">glTranslatef(-180, 0, 0);</p>
<p class="src"></p>
<p class="src1">freetype::print(our_font, 320, 240, &quot;Active FreeType Text - %7.2f&quot;, cnt1);</p>
<p class="src"></p>
<p class="src1">glPopMatrix();</p>

<p>Chcete-li otestovat i pøechody na nové øádky, odstraòte komentáø.</p>

<p class="src1"><span class="kom">// freetype::print(our_font, 320, 200, &quot;Here\nthere\nbe\n\nnewlines\n.&quot;, cnt1);</span></p>
<p class="src"></p>
<p class="src1">cnt1 += 0.051f;<span class="kom">// Zvìt¹ení hodnot v èítaèích</span></p>
<p class="src1">cnt2 += 0.005f;</p>
<p class="src"></p>
<p class="src1">return TRUE;<span class="kom">// V¹e OK</span></p>
<p class="src0">}</p>

<p>Nakonec musíme pøidat kód pro odchytávání vyjímek. Pøejdeme do WinMain() a na zaèátku vyhledáme sekci try { }.</p>

<p class="src0"><span class="kom">// WinMain()</span></p>
<p class="src1">MSG msg;<span class="kom">// Struktura zprávy</span></p>
<p class="src1">BOOL done = FALSE;<span class="kom">// Promìnná pro ukonèení cyklu</span></p>
<p class="src"></p>
<p class="src1">try<span class="kom">// Sekce, ve které se budou zachytávat vyjímky</span></p>
<p class="src1">{</p>

<p>Konec funkce modifikujeme pøidáním catch { }, které vypí¹e text vyjímky.</p>

<p class="src2">KillGLWindow();<span class="kom">// Zru¹ení okna</span></p>
<p class="src1">}</p>
<p class="src1">catch (std::exception &amp;e)<span class="kom">// O¹etøení vyjímek</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, e.what(), &quot;CAUGHT AN EXCEPTION&quot;, MB_OK | MB_ICONINFORMATION);</p>
<p class="src1">}</p>

<p>Tak a teï, kdy¾ v programu nastane vyjímka, se zobrazí text oznamující u¾ivateli, co se stalo. Pozor, tento kód mù¾e zpomalit vá¹ program, tak¾e se mo¾ná pøi kompilování koneèné verze bude hodit vypnutí odchytávání vyjímek (Project-&gt;Settings-&gt;C/C++, &quot;C++ Language&quot;).</p>

<p>Zkompilujte program. Po spu¹tìní byste mìli vidìt pìkný text renderovaný pomocí FreeType, který se pohybuje okolo originálního textu z lekce 13.</p>

<h3>Obecné poznámky</h3>

<p>Pravdìpodobnì budete chtít právì vytvoøenou FreeType knihovnu je¹tì dále vylep¹it. Konkrétnì se mù¾e jednat napø. o zarovnávání textu na støed. K tomu budete potøebovat nìjakým zpùsobem zjistit jeho délku. Jedním zpùsobem mù¾e být vlo¾ení pøíkazu glBitmap() do display listu, který bude modifikovat pozici v rastru. Prakticky v¹echno u¾ je v kódu pøipraveno, staèí odkomentáøovat pøíslu¹né pøíkazy.</p>

<p>FreeType fonty zabírají také mnohem více místa ne¾ obyèejný WGL bitmapový font. Pokud z nìjakého dùvodu potøebujete ¹etøit texturovací pamì», zkuste vytvoøit jednu texturu, která bude obsahovat matici v¹ech znakù, stejnou jaká je v lekci 13.</p>

<p>Na rozdíl od bitmap obdélníky s namapovanou texturou reprezentující text dobøe spolupracují s OpenGL picking funkcemi (lekce 32), co¾ velmi usnadòuje zji¹tìní, jestli nìkdo na text klikl my¹í nebo pøes nìj pøejel.</p>

<p>Nakonec uvádím odkazy na nìkolik knihoven fontù pro OpenGL. Zále¾í pouze na vás, jestli je budete chtít pou¾ít místo tohoto kódu.</p>

<ul>
<li><?OdkazBlank('http://www.opengl.org/developers/faqs/technical/fonts.htm', 'GLTT');?> - tato knihovna je u¾ relativnì stará. Je zalo¾ena na FreeType1. Pøedpokládám, ¾e pro kompilaci v MSVC6 budete potøebovat nalézt kopii staré distribuce FreeType1.</li>
<li><?OdkazBlank('http://oglft.sourceforge.net/', 'OGLFT');?> - je zalo¾eno na FreeType2, kompilace pod MSVC dá mo¾ná trochu práce, proto¾e byla zamìøena pøedev¹ím pro Linux...</li>
<li><?OdkazBlank('http://homepages.paradise.net.nz/henryj/code/#FTGL', 'FTGL');?> - tøetí knihovna zalo¾ená na FreeType, vyvíjena pro OS X.</li>
<li><?OdkazBlank('http://plib.sourceforge.net/fnt', 'FNT');?> - knihovna, která není zalo¾ena na FreeType, je èástí PLIB, má hezký interface, pou¾ívá vlastní formát fontù, kompilace pod MSVC6 s minimem potí¾í...</li>
</ul>

<p class="autor">napsal: Sven Olsen <?VypisEmail('sven@sccs.swarthmore.edu');?><br />
do sloven¹tiny pøelo¾il: Pavel Hradský - PcMaster<?VypisEmail('pcmaster@stonline.sk');?><br />
do èe¹tiny pøelo¾il: Michal Turek - Woq <?VypisEmail('woq@email.cz');?></p>

<h3 class="zdroj_kody_nadpis">Zdrojové kódy</h3>

<ul class="zdroj_kody">
<li><a href="http://nehe.gamedev.net/data/lessons/vc/lesson43.zip">Visual C++</a> kód této lekce.</li>
<li><a href="http://nehe.gamedev.net/data/lessons/cwarrior/lesson43.zip">Code Warrior 5.3</a> kód této lekce. ( <a href="mailto:DelusionalBeing@hotmail.com">Scott Lupton</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxsdl/lesson43.tar.gz">Linux/SDL</a> kód této lekce. ( <a href="mailto:agraves@bu.edu">Aaron Graves</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/vs_net/lesson43.zip">Visual Studio .NET</a> kód této lekce. ( <a href="mailto:webmaster@joachimrohde.de">Joachim Rohde</a> )</li>
</ul>

<?FceImgNeHeVelky(43);?>
<?FceNeHeOkolniLekce(43);?>

<?
include 'p_end.php';
?>
